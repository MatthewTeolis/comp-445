#!/usr/bin/env python3
import json
import os

from dicttoxml import dicttoxml

from httpserver.argparser.ArgParser import ArgParser
from httpserver.http.HttpResponse import HttpResponse
from httpserver.http.HttpServer import HttpServer
from httpserver.io.Directory import Directory
from httpserver.io.File import File
from httpserver.util.parser import parse_request


def get_directory_contents(path):
    """
    Get a generator containing a directory's contents.
    :param path: absolute path of directory the contents of which we want to view
    :return: generator containing list of files first and then directories (in that order), in the directory
    """
    files, directories = [], []

    for file in os.listdir(path):

        file_path = os.path.join(path, file)

        if os.path.isdir(file_path):
            directories.append(file_path)
        else:
            files.append(file_path)

    for file in files:
        yield File(file).__repr__()

    for directory in directories:
        yield Directory(directory, list(get_directory_contents(directory))).__repr__()


def get_file_contents(path):
    try:
        return open(path).read()
    except FileNotFoundError:
        return "File not found."
    except IsADirectoryError:
        return "You cannot read a directory's contents. Well, technically you can. But I won't allow it."
    except NotADirectoryError:
        return "Where do you think you're going?"


def get_json_representation(path):
    return json.dumps(list(get_directory_contents(path)))


def get_xml_representation(path):
    return dicttoxml(list(get_directory_contents(path)), custom_root="structure", attr_type=False).decode("utf-8")


# todo html and plain text
content_types = {
    "application/json": get_json_representation,
    "application/xml": get_xml_representation,
    "text/html": "text/html",
    "text/plain": "text/plain"
}


if __name__ == '__main__':
    parser = ArgParser()
    args = parser.parse_args()
    print(args)

    port = args.port
    http_server = HttpServer(port)
    print(f'Listening on port {port}')
    http_server.listen()
    client, address = http_server.accept()
    print('Connected', address)
    data = client.recv(1024).decode('utf-8')
    request = parse_request(data)
    content_type = request.headers["Content-Type"] if "Content-Type" in request.headers else "application/xml"

    if request.verb == 'GET' and request.path == '/':

        content = content_types[content_type](args.directory)
        response = HttpResponse("HTTP/1.0", 200, "OK", {"Content-Length": len(content), "Content-Type": content_type}, content).__repr__()
        client.sendall(bytes(response, "utf-8"))

    elif request.verb == 'GET' and request.path != '/':

        content = get_file_contents(os.path.join(args.directory, request.path[1:]))
        response = HttpResponse("HTTP/1.0", 200, "OK", {"Content-Length": len(content), "Content-Type": "text/plain"}, content).__repr__()
        client.sendall(bytes(response, "utf-8"))

    client.close()

    http_server.kill()

    # if args.command == 'get':
    #     (_, host, port, path) = parse_url(args.URL)
    #
    #     request = HttpRequest(host, port, 'GET', path, convert_list_headers_to_dictionary(args.h))
    #
    #     response = get(request, args.v)
    #
    #     print_or_write(response.body, args)
    #
    # elif args.command == 'post':
    #     (_, host, port, path) = parse_url(args.URL)
    #     data = get_data(args)
    #
    #     request = HttpRequest(host, port, 'POST', path, convert_list_headers_to_dictionary(args.h), data)
    #
    #     response = post(request, args.v)
    #
    #     print_or_write(response.body, args)
    #
    # elif args.command == 'help':
    #     show_help(args, parser)
    #
    # else:
    #     parser.print_help()
