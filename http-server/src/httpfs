#!/usr/bin/env python3
import json
import os
import threading

from dicttoxml import dicttoxml

from httpserver.argparser.ArgParser import ArgParser
from httpserver.http.HttpRequest import HttpRequest
from httpserver.http.HttpResponse import HttpResponse
from httpserver.http.HttpServer import HttpServer
from httpserver.io.Directory import Directory
from httpserver.io.File import File
from httpserver.util.parser import parse_request


def get_directory_contents(path, depth=0):
    """
    Get a generator containing a directory's contents.
    :param path: absolute path of directory the contents of which we want to view
    :return: generator containing files first and then directories (in that order), in the directory
    """
    files, directories = [], []

    for file in os.listdir(path):

        file_path = os.path.join(path, file)

        if os.path.isdir(file_path):
            directories.append(file_path)
        else:
            files.append(file_path)

    for file in files:
        yield File(file)

    for directory in directories:
        yield Directory(directory, get_directory_contents(directory, depth + 1), depth + 1)


def get_json_representation(path):
    return json.dumps([x.__repr__() for x in get_directory_contents(path)])


def get_xml_representation(path):
    return dicttoxml([x.__repr__() for x in get_directory_contents(path)], custom_root="structure", attr_type=False).decode("utf-8")


def get_html_representation(path):
    return ''.join([x.get_html() for x in get_directory_contents(path)])


def get_plain_text_representation(path):
    return ''.join([x.get_plain_text() for x in get_directory_contents(path)])


# todo plain text
content_types = {
    "application/json": get_json_representation,
    "application/xml": get_xml_representation,
    "text/html": get_html_representation,
    "text/plain": get_plain_text_representation
}


def response(code, status, content, content_type):
    return HttpResponse("HTTP/1.0", code, status, {"Content-Length": len(content), "Content-Type": content_type}, content).__repr__()


def list_directory(path: str, content_type: str):
    try:
        content = content_types[content_type](path)
        return response(200, "OK", content, content_type)
    except FileNotFoundError as e:
        return response(404, "Not Found", str(e), "text/plain")
    except NotADirectoryError as e:
        return response(400, "Bad Request", str(e), "text/plain")
    except KeyError:
        content = "Cannot figure out how you want to see the data."
        return response(400, "Bad Request", content, "text/plain")


def get_file_contents(path):
    content, code, status = File(path).get_contents()
    return response(code, status, content, "text/plain")


def get(path, request: HttpRequest):
    if request.path == '/':
        content_type = request.headers["Accept"].split(',')[0] if "Accept" in request.headers else "application/json"
        return list_directory(path, content_type)
    else:
        return get_file_contents(os.path.join(path, request.path[1:]))


def listen_to_client(client, address):
    print('Connected', address)
    data = client.recv(1024).decode('utf-8')
    request = parse_request(data)

    if request.verb == 'GET':
        response = get(args.directory, request)
        client.sendall(bytes(response, "utf-8"))
    elif request.verb == 'POST':
        pass

    client.close()


if __name__ == '__main__':
    parser = ArgParser()
    args = parser.parse_args()
    print(args)

    port = args.port
    http_server = HttpServer(port)

    try:
        print(f'Listening on port {port}')
        http_server.listen()

        while True:
            client, address = http_server.accept()
            threading.Thread(target=listen_to_client, args=(client, address)).start()
    except KeyboardInterrupt:
        http_server.kill()
        print('\nTerminated')


    # elif args.command == 'post':
    #     (_, host, port, path) = parse_url(args.URL)
    #     data = get_data(args)
    #
    #     request = HttpRequest(host, port, 'POST', path, convert_list_headers_to_dictionary(args.h), data)
    #
    #     response = post(request, args.v)
    #
    #     print_or_write(response.body, args)
    #
    # elif args.command == 'help':
    #     show_help(args, parser)
    #
    # else:
    #     parser.print_help()
